;; gorilla-repl.fileformat = 1

;; @@
(ns x-plus-six
  (:use midje.sweet)
  (:require [gorilla-plot.core :as plot])
  (:require [push.interpreter.templates.one-with-everything :as owe])
  (:require [push.interpreter.core :as core])
  (:require [push.util.stack-manipulation :as u])
  (:use clojure.pprint)
  )
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-nil'>nil</span>","value":"nil"}
;; <=

;; **
;;; # A trivial symbolic regression problem:
;;; ## The X-plus-6 Example
;;; 
;;; This gorilla session includes a walk-through in which I use the Push-in-Clojure interpreter for a trivially simple curve-fitting problem. I use this example in every Introduction to Genetic Programming class I teach: the simplicity of the target (and "knowing the right answer" beforehand) helps clarify a lot of how the software itself works, and the implicit decisions we make when we design a GP project.
;;; 
;;; **Note** this is not a tutorial on genetic programming. It's much more about how one designs and configures a Push-in-Clojure interpreter so one can run and evaluate Push programs. There are some very rudimentary "fitness" functions discussed, but the point here is to learn how one maps training cases from an _external_ search process (of any sort) onto the inputs and "result" values of a Push program.
;; **

;; **
;;; ## Symbolic regression with a very low bar
;;; 
;;; Suppose we have a simple task: to discover Push expressions (that is, algorithms) which _fit_ the following data:
;;; 
;;;               x    y
;;;             12.3   18.3
;;;             -2.0    4.0
;;;             33.8   39.8
;;;             10.2   16.2
;;;             -1.2    4.8
;;;      187267311.9   187267317.9
;;;     (and so on)
;;; 
;;; Regardless of how we decide to go about _searching_ for these expressions, we'll use the `push-in-clojure` library to build `Interpreter` instances to run our prospective solutions so we can score them against this training data. In this example, let me take what might be the simplest approach that could possibly work: repeated guessing, keeping the best-scoring example seen so far.
;;; 
;;; But before we start, we should ask: In what way is a Push program a "function" of the sort we're used to? Push carefully and thoroughly defines a wide variety of types and instructions, but those instructions technically transform one `Interpreter` state into another, not "inputs" into "outputs". Push has a surprisingly light hand when imposing _meaning_ on the dynamics of a running program, as a result. We can specify `input` values and manage which `instructions` will be recognized by the `Interpreter`, but there is _no aspect of the Push language_ corresponding to our common idea of "return value". Even the items on the `:print` and `:return` stacks are left uninterpreted beyond their stack names.
;;; 
;;; The most common approach for "forcing" a Push program return a particular typed result has been to take the _top item from a particular stack at a particular time_ as "the answer". We can do that here as well; the data seems to be floating-point values, so we can use the top `:float` item at (say) 3000 interpreter steps to signify the "answer".
;;; 
;;; Two things to say about this decision:
;;; 
;;; First, notice we could as easily have said the second `:float` item, or the _best_ `:float` item, or the next `:float` item pushed to that stack _after_ 3000 interpreter steps have been taken. Or we could have taken the average of all the `:integer` values on that stack, or take the entire contents of the `:print` stack, convert it to a string, and then parse that string as a floating-point value. These approaches may seem arbitrary and convoluted for this example, but keep in mind that we bring those judgments with usâ€”they are not hard-coded into the Push language's syntax or semantics.
;;; 
;;; Second, realize that there may not _be_ a `:float` value on that stack when we decide to check. There may be no `:float` literals in the program we run, or it might not even refer to the input value `x`, or we might in the course of running arbitrary code consume or delete all the `:float` values. The arbitrariness of mapping the entire Push interpreter state (all its stacks and history if we like) does not affect the deterministic but essentially arbitrary dynamics of running a program.
;;; 
;;; This leaves us with a question of how to model "results" for programs that don't even give us the input to our defined "return function" (top thing on the `:float` stack after 3000 steps). Should we use a default value? Should we permit "no answer given" as the _result_, and somehow penalize the _score_ of a program that gives that result? Or should we immediately discard any program that provides no `:float` value (which is a sort of Extremely Large Immediate Penalty function)?
;;; 
;;; Here I'll stick with "top `:float` at 3000 steps, if any", and immediately discard any program that gives no answer.
;;; 
;; **

;; **
;;; 
;;; ## Guessing
;;; 
;;; Finally, there's the question we should ask next: What's a "guess"?
;;; 
;;; The `push-in-clojure` package includes a number of "template" interpreters, so let's use one of those as a basis. To make things interesting (and also to drive home the point that a Push program imposes almost no semantic meaning on your input:output choices), let's use the one called `one-with-everything`, which piles every defined Push type, module, aspect and instruction into one convenient jumble.
;;; 
;;; We'll want an input value, call it `:x`, but otherwise it's as simple as this:
;;; 
;;; 
;; **

;; @@
(def my-interpreter (owe/make-everything-interpreter :inputs {:x nil}))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;x-plus-six/my-interpreter</span>","value":"#'x-plus-six/my-interpreter"}
;; <=

;; **
;;; Let me exercise that `Interpreter` instance here in a Midje test, just to show what all it knows already.
;; **

;; @@
(fact "my-interpreter knows some things"
  (keys (:instructions my-interpreter)) =>
    (contains [:integer-subtract :exec-while] :gaps-ok :in-any-order)

  (< 400 (count (:instructions my-interpreter))) => truthy

  (map :name (:types my-interpreter)) => '(:set :vector :strings :integers :floats :chars :booleans :string :float :char :boolean :integer)

  (keys (:inputs my-interpreter)) => '(:x))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-unkown'>true</span>","value":"true"}
;; <=

;; **
;;; 
;;; That seems like it should more than suffice.
;;; 
;;; A Push program is a vector of items: instruction keys, input keys, literal values and lists of those things. For example, both `[1 (false [4 3 1] :code-flush)]` and `[:x 6 "blueberry" :integer-add :integer->float]` are valid Push programs this interpreter would recognize and run. Any vector of these sorts of valid item, of any length, would be a valid "guess" for our algorithm to match the data. The first trick is arguably being able to pick random _valid_ programs that this interpreter will recognize and run.
;;; 
;;; As the preceding tests imply, a new Push `Interpreter` instance already knows and can communicate a lot about the things it will do and recognize. Looking at those `midje` results, we know it already can deal with literal values of these types:
;;; 
;;; - `:boolean`
;;; - `:booleans`
;;; - `:char`
;;; - `:chars`
;;; - `:integer`
;;; - `:integers`
;;; - `:float`
;;; - `:floats`
;;; - `:set`
;;; - `:string`
;;; - `:strings`
;;; - `:vector`
;;; 
;;; We know it can also recognize a bunch of instructions:
;;; 
;; **

;; @@
(fact "the number of instructions known ain't small"
  (count (:instructions my-interpreter)) => 587) ;; as of this writing

;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-unkown'>true</span>","value":"true"}
;; <=

;; **
;;; ... and what those instructions are:
;; **

;; @@
(fact "my-interpreter can tell us the instructions it knows"
  (sort (keys (:instructions my-interpreter))) =>
    '(:boolean->code :boolean->float :boolean->integer :boolean->signedfloat :boolean->signedint :boolean->string :boolean-and :boolean-cutflip :boolean-cutstack :boolean-dup :boolean-empty? :boolean-equal? :boolean-flipstack :boolean-flush :boolean-not :boolean-notequal? :boolean-or :boolean-pop :boolean-print :boolean-return :boolean-return-pop :boolean-rotate :boolean-shove :boolean-stackdepth :boolean-swap :boolean-xor :boolean-yank :boolean-yankdup :booleans->code :booleans-butlast :booleans-concat :booleans-conj :booleans-contains? :booleans-cutflip :booleans-cutstack :booleans-do*each :booleans-dup :booleans-empty? :booleans-emptyitem? :booleans-equal? :booleans-first :booleans-flipstack :booleans-flush :booleans-fromexample :booleans-generalize :booleans-generalizeall :booleans-indexof :booleans-last :booleans-length :booleans-new :booleans-notequal? :booleans-nth :booleans-occurrencesof :booleans-pop :booleans-portion :booleans-print :booleans-remove :booleans-replace :booleans-replacefirst :booleans-rest :booleans-return :booleans-return-pop :booleans-reverse :booleans-rotate :booleans-set :booleans-shatter :booleans-shove :booleans-stackdepth :booleans-swap :booleans-take :booleans-yank :booleans-yankdup :char->code :char->float :char->integer :char->string :char-cutflip :char-cutstack :char-digit? :char-dup :char-empty? :char-equal? :char-flipstack :char-flush :char-letter? :char-lowercase? :char-max :char-min :char-notequal? :char-pop :char-print :char-return :char-return-pop :char-rotate :char-shove :char-stackdepth :char-swap :char-uppercase? :char-whitespace? :char-yank :char-yankdup :char<? :char>? :chars->code :chars-butlast :chars-concat :chars-conj :chars-contains? :chars-cutflip :chars-cutstack :chars-do*each :chars-dup :chars-empty? :chars-emptyitem? :chars-equal? :chars-first :chars-flipstack :chars-flush :chars-fromexample :chars-generalize :chars-generalizeall :chars-indexof :chars-last :chars-length :chars-new :chars-notequal? :chars-nth :chars-occurrencesof :chars-pop :chars-portion :chars-print :chars-remove :chars-replace :chars-replacefirst :chars-rest :chars-return :chars-return-pop :chars-reverse :chars-rotate :chars-set :chars-shatter :chars-shove :chars-stackdepth :chars-swap :chars-take :chars-yank :chars-yankdup :charâ‰¤? :charâ‰¥? :code->set :code->string :code-append :code-atom? :code-cons :code-container :code-contains? :code-cutflip :code-cutstack :code-do :code-do* :code-do*count :code-do*range :code-do*times :code-drop :code-dup :code-empty? :code-equal? :code-extract :code-first :code-flipstack :code-flush :code-if :code-insert :code-length :code-list :code-map :code-member? :code-noop :code-notequal? :code-nth :code-null? :code-points :code-pop :code-position :code-print :code-quote :code-reduce :code-rest :code-return :code-return-pop :code-rotate :code-shove :code-size :code-stackdepth :code-subst :code-swap :code-wrap :code-yank :code-yankdup :environment-begin :environment-empty? :environment-end :environment-new :environment-stackdepth :error-empty? :error-stackdepth :exec->string :exec-cutflip :exec-cutstack :exec-do*count :exec-do*range :exec-do*times :exec-do*while :exec-dup :exec-empty? :exec-equal? :exec-flipstack :exec-flush :exec-if :exec-k :exec-noop :exec-notequal? :exec-pop :exec-print :exec-return :exec-return-pop :exec-rotate :exec-s :exec-shove :exec-stackdepth :exec-string-iterate :exec-swap :exec-when :exec-while :exec-y :exec-yank :exec-yankdup :float->asciichar :float->boolean :float->char :float->code :float->integer :float->string :float-add :float-cosine :float-cutflip :float-cutstack :float-dec :float-divide :float-dup :float-empty? :float-equal? :float-flipstack :float-flush :float-inc :float-max :float-min :float-mod :float-multiply :float-notequal? :float-pop :float-print :float-return :float-return-pop :float-rotate :float-shove :float-sign :float-sine :float-stackdepth :float-subtract :float-swap :float-tangent :float-yank :float-yankdup :float<? :float>? :floats->code :floats-butlast :floats-concat :floats-conj :floats-contains? :floats-cutflip :floats-cutstack :floats-do*each :floats-dup :floats-empty? :floats-emptyitem? :floats-equal? :floats-first :floats-flipstack :floats-flush :floats-fromexample :floats-generalize :floats-generalizeall :floats-indexof :floats-last :floats-length :floats-new :floats-notequal? :floats-nth :floats-occurrencesof :floats-pop :floats-portion :floats-print :floats-remove :floats-replace :floats-replacefirst :floats-rest :floats-return :floats-return-pop :floats-reverse :floats-rotate :floats-set :floats-shatter :floats-shove :floats-stackdepth :floats-swap :floats-take :floats-yank :floats-yankdup :floatsign->boolean :floatâ‰¤? :floatâ‰¥? :integer->asciichar :integer->boolean :integer->char :integer->code :integer->float :integer->string :integer-add :integer-cutflip :integer-cutstack :integer-dec :integer-divide :integer-dup :integer-empty? :integer-equal? :integer-few :integer-flipstack :integer-flush :integer-inc :integer-lots :integer-many :integer-max :integer-min :integer-mod :integer-multiply :integer-notequal? :integer-pop :integer-print :integer-return :integer-return-pop :integer-rotate :integer-shove :integer-sign :integer-some :integer-stackdepth :integer-subtract :integer-swap :integer-yank :integer-yankdup :integer<? :integer>? :integers->code :integers-butlast :integers-concat :integers-conj :integers-contains? :integers-cutflip :integers-cutstack :integers-do*each :integers-dup :integers-empty? :integers-emptyitem? :integers-equal? :integers-first :integers-flipstack :integers-flush :integers-fromexample :integers-generalize :integers-generalizeall :integers-indexof :integers-last :integers-length :integers-new :integers-notequal? :integers-nth :integers-occurrencesof :integers-pop :integers-portion :integers-print :integers-remove :integers-replace :integers-replacefirst :integers-rest :integers-return :integers-return-pop :integers-reverse :integers-rotate :integers-set :integers-shatter :integers-shove :integers-stackdepth :integers-swap :integers-take :integers-yank :integers-yankdup :integerâ‰¤? :integerâ‰¥? :intsign->boolean :log-empty? :log-stackdepth :print-empty? :print-newline :print-space :print-stackdepth :push-counter :push-inputs :push-inputset :push-instructionset :set->code :set-cutflip :set-cutstack :set-difference :set-dup :set-empty? :set-equal? :set-flipstack :set-flush :set-intersection :set-notequal? :set-pop :set-print :set-return :set-return-pop :set-rotate :set-shove :set-stackdepth :set-subset? :set-superset? :set-swap :set-union :set-yank :set-yankdup :string->chars :string->code :string->float :string->integer :string-butlast :string-concat :string-conjchar :string-contains? :string-containschar? :string-cutflip :string-cutstack :string-dup :string-empty? :string-emptystring? :string-equal? :string-first :string-flipstack :string-flush :string-indexofchar :string-last :string-length :string-max :string-min :string-notequal? :string-nth :string-occurrencesofchar :string-pop :string-print :string-removechar :string-replace :string-replacechar :string-replacefirst :string-replacefirstchar :string-rest :string-return :string-return-pop :string-reverse :string-rotate :string-setchar :string-shatter :string-shove :string-solid? :string-spacey? :string-splitonspaces :string-stackdepth :string-substring :string-swap :string-take :string-yank :string-yankdup :string<? :string>? :strings->code :strings-butlast :strings-concat :strings-conj :strings-contains? :strings-cutflip :strings-cutstack :strings-do*each :strings-dup :strings-empty? :strings-emptyitem? :strings-equal? :strings-first :strings-flipstack :strings-flush :strings-fromexample :strings-generalize :strings-generalizeall :strings-indexof :strings-last :strings-length :strings-new :strings-notequal? :strings-nth :strings-occurrencesof :strings-pop :strings-portion :strings-print :strings-remove :strings-replace :strings-replacefirst :strings-rest :strings-return :strings-return-pop :strings-reverse :strings-rotate :strings-set :strings-shatter :strings-shove :strings-stackdepth :strings-swap :strings-take :strings-yank :strings-yankdup :stringâ‰¤? :stringâ‰¥? :vector->code :vector->set :vector-butlast :vector-concat :vector-conj :vector-contains? :vector-cutflip :vector-cutstack :vector-do*each :vector-dup :vector-empty? :vector-emptyitem? :vector-equal? :vector-first :vector-flipstack :vector-flush :vector-fromexample :vector-indexof :vector-last :vector-length :vector-new :vector-notequal? :vector-nth :vector-occurrencesof :vector-pop :vector-portion :vector-print :vector-refilter :vector-refilterall :vector-remove :vector-replace :vector-replacefirst :vector-rest :vector-return :vector-return-pop :vector-reverse :vector-rotate :vector-set :vector-shatter :vector-shove :vector-stackdepth :vector-swap :vector-take :vector-yank :vector-yankdup)
    )


;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-unkown'>true</span>","value":"true"}
;; <=

;; **
;;; That feels like a lot of instructions, but to be honest most of them are simple take-one-of-these-and-put-it-over-there "movers" and "converters".
;; **

;; **
;;; If I'm going to be making random Push programs from these instructions, I'll need to have a way of selecting random instructions. And by force of habit, I also want there to be at least a few kinds of random literal values, and probably I should give them access to the input variable `:x` I've defined. So let's define a few functions to that end here:
;; **

;; @@
(defn random-instruction
  [interpreter]
  (rand-nth (keys (:instructions interpreter))))


(defn random-float
  [scale]
  (* scale (/ (rand-int scale) 32.0)))


(defn random-integer
  [scale]
  (rand-int scale))


(defn random-input
  [interpreter]
  (rand-nth (keys (:inputs interpreter))))


(defn random-boolean
  []
  (< 0.5 (rand)))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;x-plus-six/random-boolean</span>","value":"#'x-plus-six/random-boolean"}
;; <=

;; **
;;; That should do, at least for a simple "guess". I can pick (with uniform probability) any of the `instructions` from an interpreter, a floating-point number, an integer, any of the defined `inputs` from an interpreter, and a coin-flip `true`/`false` value.
;;; 
;;; A lot of the complex behavior of Push code-composing instructions depends on the presence of _lists_ of things (including other lists of things) in the programs, so let's write a function for making those as well. At this point anything seems reasonable (after all, I'm throwing it in out of curiosity), so how about little chunks of five other items?
;;; 
;;; The trick of course is that I'd like a "list of `random-push-item`" to actually _be_ a kind of `random-push-item`, so I'll need to `declare` that function here first, before I define it below.
;; **

;; @@
(declare random-push-item)

(defn random-code
  [interpreter length]
  (into '() (repeatedly length #(random-push-item interpreter))))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;x-plus-six/random-code</span>","value":"#'x-plus-six/random-code"}
;; <=

;; **
;;; And that's about it. Now I can write a little dice-rolling function to pick a `random-push-item`, leaving myself room to fiddle around with the relative probabilities of the different kinds of item because that seems like it might be salient. A `random-push-program` is simply a vector filled with those things.
;; **

;; @@
(defn random-push-item
  [interpreter]
  (let [diceroll (rand-int 20)]
    (condp <= diceroll
      15 (random-float 100)
      13 (random-integer 100)
      11 (random-boolean)
      9 (random-input my-interpreter)
      6 (random-code my-interpreter 5)
      (random-instruction interpreter)
      )))


(defn random-push-program
  [length]
  (into [] (repeatedly length #(random-push-item my-interpreter))))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;x-plus-six/random-push-program</span>","value":"#'x-plus-six/random-push-program"}
;; <=

;; **
;;; ### No "Genomes"
;;; 
;;; I feel it's important to note there is no separate "genome" data structure in this example, even though there will be in almost any interesting GP project. What I've been building here is simply a way of generating a Push _program_, which is to say runnable code as far as our `Interpreter` is concerned.
;;; 
;;; Most "genome" structures (scare quotes intentional, because you don't need to be evolving populations or invoking that biological metaphor) differ from runnable code in support of _evolvability_ or more generally _mutability_. That is, there are extra data structure aspects of "genomes" which have nothing to do with what the final program an `Interpreter` runs will do, but which rather help you snip up different prospects or transform them in some other useful way as you incrementally improve them. They're a layer of semantics that doesn't refer to the running program, but rather in the other direction to the search algorithm you're using.
;; **

;; **
;;; ### Checking to see
;;; 
;;; I should have a look and see what my `random-push-program` produces.
;; **

;; @@
(def my-sample (random-push-program 7))

(println my-sample)

(def my-stable-sample          ;; this is one I "prepared earlier"
'[:integer-max 300.0 ( :x ( :integers-flipstack 171.875 31 true true) 106.25 :x true) 246.875 30 :char-shove ( 28 :strings-generalize :booleans-yankdup :print-empty? ( 203.125 :chars-stackdepth false :x 221.875))])
;; @@
;; ->
;;; [:chars-butlast ((false :chars-emptyitem? (32 91 :set-shove :x false) :chars-generalizeall (:float-pop :integer-min true 100.0 :integerâ‰¤?)) (52 (((200.0 :set-difference 175.0 false 225.0) (3.125 43.75 :floats-equal? :float-equal? 12.5) 65.625 :vector-replacefirst (68.75 (50.0 94 true 0 (243.75 67 (:boolean-empty? :code-empty? true 45 :strings-&gt;code) 212.5 :x)) :string-pop :integer-many :x)) :x 203.125 :char-&gt;code 3) 6.25 :x :set-print) :x ((16 :float-return :string&lt;? :x :booleans-print) 56.25 :push-inputset 0.0 65.625) :booleans-fromexample) 75 :integers-notequal? ((162.5 :exec-if :floats-flipstack 171.875 11) 178.125 false (49 :booleans-shatter (81.25 (43.75 :x 203.125 284.375 :exec-return-pop) 46 196.875 (246.875 137.5 ((175.0 :float-yankdup 62.5 45 84.375) 287.5 175.0 false 262.5) (82 228.125 75.0 :code-quote :x) :integer-min)) 31.25 :x) (58 :boolean-xor :integer-&gt;asciichar 281.25 (:booleans-occurrencesof 156.25 0 81.25 268.75))) 259.375 :string-&gt;chars]
;;; 
;; <-
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;x-plus-six/my-stable-sample</span>","value":"#'x-plus-six/my-stable-sample"}
;; <=

;; **
;;; That preceding cell will be dynamically calculated every time this worksheet is re-evaluated, so I've gone ahead and run it myself, copied the random program my run produced, and saved it in the `var` `my-stable-sample` so we I can talk about it here. In case the formatting of the previous cell has changed, let me copy `my-stable-sample` over here, and format it a bit by hand to highlight its nested structure:
;;; 
;;;     [:integer-max
;;;      300.0 
;;;      ( :x 
;;;        ( :integers-flipstack 
;;;          171.875 
;;;          31 
;;;          true 
;;;          true) 
;;;        106.25 
;;;        :x 
;;;        true) 
;;;      246.875 
;;;      30 
;;;      :char-shove 
;;;      ( 28 
;;;        :strings-generalize 
;;;        :booleans-yankdup 
;;;        :print-empty? 
;;;        ( 203.125 
;;;        	 :chars-stackdepth 
;;;          false 
;;;          :x 
;;;          221.875))]
;;; 
;;; So that's interesting (for some definition of "interesting").
;;; 
;;; It's more than seven items, which might surprise you, since there are a few `random-code` items tucked in (nested, actually), and each of _those_ contains five items of its own. But there are seven _root_ items in this program vector, which is what I asked for. Seems fine from here. I might (but doubt I will) worry about how large a tree this might make in extreme cases where it's entirely `random-code` with `random-code` inside it and so forth, but... nah.
;; **

;; **
;;; ## Exercising random programs
;;; 
;;; I made an `Interpreter` instance a while back. Let's run my random program and see what I get. A whole Push `Interpreter` instance is huge, though, and I don't want to print the entire thing here. Let me just peek at what's on its stacks before and after I run the program:
;; **

;; @@
;; before

(def sample-before
  (core/recycle-interpreter
  	my-interpreter
    my-stable-sample
    :inputs {:x 10}))

(pprint (:stacks sample-before))
;; @@
;; ->
;;; {:booleans (),
;;;  :integers (),
;;;  :unknown (),
;;;  :exec
;;;  (:integer-max
;;;   300.0
;;;   (:x (:integers-flipstack 171.875 31 true true) 106.25 :x true)
;;;   246.875
;;;   30
;;;   :char-shove
;;;   (28
;;;    :strings-generalize
;;;    :booleans-yankdup
;;;    :print-empty?
;;;    (203.125 :chars-stackdepth false :x 221.875))),
;;;  :return (),
;;;  :float (),
;;;  :strings (),
;;;  :string (),
;;;  :vector (),
;;;  :print (),
;;;  :integer (),
;;;  :chars (),
;;;  :code (),
;;;  :error (),
;;;  :environment (),
;;;  :set (),
;;;  :log (),
;;;  :boolean (),
;;;  :char (),
;;;  :floats ()}
;;; 
;; <-
;; =>
;;; {"type":"html","content":"<span class='clj-nil'>nil</span>","value":"nil"}
;; <=

;; **
;;; Again, because the cell might be recalculated differently if the worksheet gets re-evaluated, for my pet sample that was:
;;; 
;;;     {:booleans (),
;;;      :integers (),
;;;      :unknown (),
;;;      :exec
;;;      (:integer-max
;;;       300.0
;;;       (:x (:integers-flipstack 171.875 31 true true) 106.25 :x true)
;;;       246.875
;;;       30
;;;       :char-shove
;;;       (28
;;;        :strings-generalize
;;;        :booleans-yankdup
;;;        :print-empty?
;;;        (203.125 :chars-stackdepth false :x 221.875))),
;;;      :return (),
;;;      :float (),
;;;      :strings (),
;;;      :string (),
;;;      :vector (),
;;;      :print (),
;;;      :integer (),
;;;      :chars (),
;;;      :code (),
;;;      :error (),
;;;      :environment (),
;;;      :set (),
;;;      :log (),
;;;      :boolean (),
;;;      :char (),
;;;      :floats ()}
;;;      
;;; You can see the program itself, loaded onto the `:exec` stack here, ready to be run. So I'll run it.
;; **

;; @@
;; after

(def sample-after
  (core/run sample-before 3000))
 
(pprint (:stacks sample-after))
;; @@
;; ->
;;; {:booleans (),
;;;  :integers (),
;;;  :unknown (),
;;;  :exec (),
;;;  :return (),
;;;  :float (221.875 203.125 246.875 106.25 171.875 300.0),
;;;  :strings (),
;;;  :string (),
;;;  :vector (),
;;;  :print (),
;;;  :integer (10 0 28 30 10 31 10),
;;;  :chars (),
;;;  :code (),
;;;  :error
;;;  ({:step 22, :item &quot;:booleans-yankdup missing arguments&quot;}
;;;   {:step 21, :item &quot;:strings-generalize missing arguments&quot;}
;;;   {:step 18, :item &quot;:char-shove missing arguments&quot;}
;;;   {:step 1, :item &quot;:integer-max missing arguments&quot;}),
;;;  :environment (),
;;;  :set (),
;;;  :log
;;;  ({:step 30, :item 221.875}
;;;   {:step 29, :item 10}
;;;   {:step 28, :item :x}
;;;   {:step 27, :item false}
;;;   {:step 26, :item :chars-stackdepth}
;;;   {:step 25, :item 203.125}
;;;   {:step 24, :item (203.125 :chars-stackdepth false :x 221.875)}
;;;   {:step 23, :item :print-empty?}
;;;   {:step 22, :item :booleans-yankdup}
;;;   {:step 21, :item :strings-generalize}
;;;   {:step 20, :item 28}
;;;   {:step 19,
;;;    :item
;;;    (28
;;;     :strings-generalize
;;;     :booleans-yankdup
;;;     :print-empty?
;;;     (203.125 :chars-stackdepth false :x 221.875))}
;;;   {:step 18, :item :char-shove}
;;;   {:step 17, :item 30}
;;;   {:step 16, :item 246.875}
;;;   {:step 15, :item true}
;;;   {:step 14, :item 10}
;;;   {:step 13, :item :x}
;;;   {:step 12, :item 106.25}
;;;   {:step 11, :item true}
;;;   {:step 10, :item true}
;;;   {:step 9, :item 31}
;;;   {:step 8, :item 171.875}
;;;   {:step 7, :item :integers-flipstack}
;;;   {:step 6, :item (:integers-flipstack 171.875 31 true true)}
;;;   {:step 5, :item 10}
;;;   {:step 4, :item :x}
;;;   {:step 3,
;;;    :item
;;;    (:x (:integers-flipstack 171.875 31 true true) 106.25 :x true)}
;;;   {:step 2, :item 300.0}
;;;   {:step 1, :item :integer-max}),
;;;  :boolean (false true true true true),
;;;  :char (),
;;;  :floats ()}
;;; 
;; <-
;; =>
;;; {"type":"html","content":"<span class='clj-nil'>nil</span>","value":"nil"}
;; <=

;; **
;;; And for my sample that was:
;;; 
;;;     {:booleans (),
;;;      :integers (),
;;;      :unknown (),
;;;      :exec (),
;;;      :return (),
;;;      :float (221.875 203.125 246.875 106.25 171.875 300.0),
;;;      :strings (),
;;;      :string (),
;;;      :vector (),
;;;      :print (),
;;;      :integer (10 0 28 30 10 31 10),
;;;      :chars (),
;;;      :code (),
;;;      :error
;;;      ({:step 22, :item ":booleans-yankdup missing arguments"}
;;;       {:step 21, :item ":strings-generalize missing arguments"}
;;;       {:step 18, :item ":char-shove missing arguments"}
;;;       {:step 1, :item ":integer-max missing arguments"}),
;;;      :environment (),
;;;      :set (),
;;;      :log
;;;      ({:step 30, :item 221.875}
;;;       {:step 29, :item 10}
;;;       {:step 28, :item :x}
;;;       {:step 27, :item false}
;;;       {:step 26, :item :chars-stackdepth}
;;;       {:step 25, :item 203.125}
;;;       {:step 24, :item (203.125 :chars-stackdepth false :x 221.875)}
;;;       {:step 23, :item :print-empty?}
;;;       {:step 22, :item :booleans-yankdup}
;;;       {:step 21, :item :strings-generalize}
;;;       {:step 20, :item 28}
;;;       {:step 19,
;;;        :item
;;;        (28
;;;         :strings-generalize
;;;         :booleans-yankdup
;;;         :print-empty?
;;;         (203.125 :chars-stackdepth false :x 221.875))}
;;;       {:step 18, :item :char-shove}
;;;       {:step 17, :item 30}
;;;       {:step 16, :item 246.875}
;;;       {:step 15, :item true}
;;;       {:step 14, :item 10}
;;;       {:step 13, :item :x}
;;;       {:step 12, :item 106.25}
;;;       {:step 11, :item true}
;;;       {:step 10, :item true}
;;;       {:step 9, :item 31}
;;;       {:step 8, :item 171.875}
;;;       {:step 7, :item :integers-flipstack}
;;;       {:step 6, :item (:integers-flipstack 171.875 31 true true)}
;;;       {:step 5, :item 10}
;;;       {:step 4, :item :x}
;;;       {:step 3,
;;;        :item
;;;        (:x (:integers-flipstack 171.875 31 true true) 106.25 :x true)}
;;;       {:step 2, :item 300.0}
;;;       {:step 1, :item :integer-max}),
;;;      :boolean (false true true true true),
;;;      :char (),
;;;      :floats ()}
;; **

;; **
;;; As you can see, there's a lot going on when I run even a little Push program. There are entries on the `:log` stack for every item that was popped from `:exec` during the run, and there are items on the `:error` stack noting when arguments were missing for instructions that were invoked by the interpreter. If you gloss over those for the time being, the important things to see are a few simpler items tucked onto the other stacks: some `:boolean` and `:integer` items, and a bunch of `:float` items. Some of those are simply literals from the original program, pushed to the appropriate stacks. But a few arose as the result of instructions executed: there was a `:chars-stackdepth` instruction that returned a `0` value, for example. Not much else, though.
;;; 
;;; It doesn't seem to be a very good prospect for calculating @@y=x+6@@, does it?
;;; 
;;; Well, except that it also looked at `x` at least twice in the course of the run. So it's "paying attention" a bit. We will want to be able to encourage that sort of thing.
;; **

;; **
;;; ### Scoring
;;; 
;;; As I said above, I think we'll take the most common approach here, and interpret the top item on the `:float` stack after a program has gone a maximum of 3000 steps. That value will be our program's predicted @@y@@, for the `:x` input we pass in.
;; **

;; @@
(defn top-float
  [interpreter]
  (first (u/get-stack interpreter :float)))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;x-plus-six/top-float</span>","value":"#'x-plus-six/top-float"}
;; <=

;; **
;;; I should be able to get the `top-float` now:
;; **

;; @@
(top-float sample-after)
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-double'>221.875</span>","value":"221.875"}
;; <=

;; **
;;; Now I said I'd like to evaluate the programs over all the training data, so let's grab that from the list I provided above:
;; **

;; @@
(def training-cases
  [ {:x 12.3 :y 18.3}
    {:x -2.0 :y 4.0}
    {:x 33.8 :y 39.8}
    {:x 10.2 :y 16.2}
    {:x -1.2 :y 4.8}
    {:x 187267311.9 :y 187267317.9}])
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;x-plus-six/training-cases</span>","value":"#'x-plus-six/training-cases"}
;; <=

;; @@
(defn evaluate-one-case
  [program io-pair]
  (let [dude (core/recycle-interpreter
                my-interpreter
                program
                :inputs {:x (:x io-pair)})
        result (top-float (core/run dude 3000))]
    (if (nil? result)
      999999999
      (Math/abs (- (:y io-pair) result)))))

(defn sum-absolute-errors-of-program
  [program io-pairs]
  (reduce #(+ %1 (Math/abs (evaluate-one-case program %2))) 0 io-pairs))
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;x-plus-six/sum-absolute-errors-of-program</span>","value":"#'x-plus-six/sum-absolute-errors-of-program"}
;; <=

;; **
;;; That might give me what I need. Let's see; the program I saved in `my-stable-sample` always returns `221.875` (for any input `:x`), so I should be able to see pretty clearly how the scores change with the different desired @@y@@ values in `training-cases`:
;; **

;; @@
(fact "I can evaluate a program with different io pairs"
	(evaluate-one-case my-stable-sample (first training-cases)) => 203.575  ;; y = 18.3
    (evaluate-one-case my-stable-sample (second training-cases)) => 217.875 ;; y = 4.0
    )

(fact "A 'perfect' program gives zero error"
	(evaluate-one-case [18.3] (first training-cases)) => 0.0                ;; y = 18.3
    (evaluate-one-case [4.0] (second training-cases)) => 0.0                ;; y = 4.0
    )

(fact "A nonresponding program has a score of 9999â€¦"
	(evaluate-one-case [false] (first training-cases)) => 999999999)


;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-unkown'>true</span>","value":"true"}
;; <=

;; **
;;; Those look about right for the absolute errors on `my-stable-program`, and just to make sure in the second Midje fact I'm evaluating a program (in each case) that "returns" the correct `:float` value and does nothing else.
;;; 
;;; So now I'm comfrotable evaluating these over all the training cases:
;; **

;; @@
(fact "A perfect program has 0.0 score over all training pairs"
	(sum-absolute-errors-of-program
      [:x 6.0 :float-add]              ;; this is a perfect fit, but you know that already
      training-cases) => 0.0
    )

(fact "An imperfect program has a substantial positive score"
    (sum-absolute-errors-of-program my-stable-sample training-cases) =>
      (roughly 187200000))             
									   ;; I cheated here, and peeked at the actual result
;; @@
;; =>
;;; {"type":"html","content":"<span class='clj-unkown'>true</span>","value":"true"}
;; <=

;; **
;;; 
;; **

;; **
;;; [WORK IN PROGRESS FOLLOWS]
;; **

;; @@
(fact "I can sample and score a bunch of random programs"
  (println (sort (take 20 (repeatedly
    #(let [dude (random-push-program 100)
        ran-him (core/run (core/recycle-interpreter
                            my-interpreter
                            dude
                            :inputs {:x -12.0}) 3000)]
          (sum-absolute-errors-of-program
            dude
            training-cases)))))))


(defn modify-program
  [program]
  (let [which (rand-int (count program))
        what (random-push-item)]
    (into [] (concat (take which program) what (drop which program)))
    ))


(def starter (random-push-program 50))
;; @@
;; ->
;;; (36.0 36.0 36.0 36.0 36.0 1.872673709E8 1.87267401E8 1.872674223E8 1.872674723E8 1.872675848E8 1.872676348E8 1.872676473E8 1.872677348E8 1.872677723E8 1.872678973E8 1.872679598E8 1.872680223E8 1.872682223E8 1.872683098E8 1.872684223E8)
;;; 
;; <-
;; =>
;;; {"type":"html","content":"<span class='clj-var'>#&#x27;x-plus-six/starter</span>","value":"#'x-plus-six/starter"}
;; <=

;; @@

;; @@

;; @@

;; @@

;; @@

;; @@
